             +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Mohamed Magdy       19016479            <imohamedpro@icloud.com>
Karim Alaa          19016172            <karimalaa1912@gmail.com>
Youhanna Yousry     19016899            <youhanna.yousry.2580@gmail.com>
Youssef Magdi       19016937            <youssefmagdi1210@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

--> NA

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

--> The command line is splitted using strtok_t() and then each argument
    is trimmed. Then we stored the arument in reverse order in an array and
    saved the number of the arguments.
    To avoid overflowing the stack, we have put a limit of a 128 bytes
    on the command line (i.e., anything thing above the limit will be truncated). 

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

--> strtok_r() is a reentrant function, that is it uses another argument
    to save the function state (next character to start with), unlike strtok()
    which saves this state internally.
    This comes in handy in preemptive environemts such as Pintos, where 
    one thread can be preempted to run another thead, thus a race condition
    will occur on shared resources like the internal state of strtok() will lead to 
    non determintistic results.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

--> 1- Seperateing command in kernel imposes an overhead, and the kernel code should be 
       minimal to let other processes to use the cpu.
    2- Unix approche leaves a space for the shell developpers to customize their product,
       adding complex and user friendly features.


                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

    struct thread {
        ...
        /*User program fields*/
        struct list open_files;                /* keeps track of opened file by the process */
        struct list child_processes;           /* keeps track of all child processes */
        struct thread *parent_thread;          /* points to the parent of the thread */
        bool child_creataion_success;          /* status of child creation */
        int child_status;                      /* status of child process that we wait on */
        struct semaphore sema_child_wait;      /* used to wait for child process */
        struct semaphore parent_child_sync;    /* synchonizes between parent and child */
        struct file *executable_file;          /* executable of the process */
        int fd_last;                           /* file descriptor of the next file to be open*/
        struct list_elem child_elem;           /* child element in parent children list */
        tid_t child_waiting_on;                /* thread id of the child that thread waits on */
        int exit_code;                         /* exit code used to determine exit status */       
        ...
    }

    struct open_file {
        int fd;                               /*file descriptor*/      
        struct file *fp;                      /*file pointer*/
        struct list_elem elem;                /**list element used in open files list in thread./
    }

    static struct lock files_sync_lock;       /*lock for sync between files*/

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

--> Each open file has a struct containg its file descriptor, file pointer
    and list element. This struct is used to append the open files of a thread
    in its open files list. To retrieve a file from its file descriptor, we search
    the list for the file.
    File descriptors are unique withing a single process.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

--> The kernel pops the file descriptor, the buffer to be read/wirtten
    and its size. Then the whole buffer is validated. 
    After the validation, the file system function read/write is called
    (input_getc() in case of console read, putbuf() in case of console write).
    within a lock (acquire -> call function -> release). 
    The number of read/written bytes is then returned.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

--> In our implementation only 2 bytes are checked to validate a buffer,
    the first and the last bytes are checked to be within the valid range.
    No further improvements can be done.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

- When a parent process calls wait on a child process, first it checks
  if the passed pid belongs to parent or not. If it belongs to parent,
  it wakes up the child process (which is blocked by default) and the
  parent is blocked. The child then starts its execution and when it
  ends (calls exit system call) which calls thread_exit() and then calls
  process_exit()  after it relases its resources, it checks if the parent 
  was waiting for the child process. If so, it updates parent.child_status 
  to the exit code and wakes up the parent thorugh sema_up() call.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

- All pointer validation is handled through function validate_void_ptr()
  which checks if address is >= PHYS_BASE or outside current process
  page. If so it calls the system call exit(-1), which calls process_exit()
  eventually, and all resources are relased inside it. 
  (Ex: child_list, closing open files or relasing locks).
- Also inside page_fault(), exit(-1) is called in case of any unpredicted
  page faults.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

- Inside process_execute() function, the parent is slept by calling
  sema_down(parent.parent_child_sync).
- When function load() is done by child process, it updates 
  parent.child_creataion_success to the sucess/failure status
  through parent pointer saved in child.
- When parent wakes up  it checks child_creataion_success value
  if it was false then creation failed and returns -1, else if
  it was true then creation successeded and returns new pid.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

- In each of previous cases, the child must call exit() sys call,
  which eventually will call process_exit() releasing all resources.

- If P called wait before C exits, C will be woken up using 
  sema_up(C.parent_child_sync) P will be blocked using 
  sema_down(P.sema_child_wait) and C will continue its 
  execution until it exits, and then it will update
  parent.child_status and wakes up the parent process,
  retreving child's exit code from its field (child_status).

- If P called wait after C exits, thus C exited by a loading error
  and the parent will not find the child among child_list, returning -1.
  In previous case C must be exited by a loading error because the
  child only continue its execution (wakes up) only if the parent
  called wait() on it or parent already exited, so it must be a
  loading error.

- If P terminates without waiting, it will wake up 
  all childern, while updating parent pointer of all
  of them to NULL, so the child process will not need 
  to remove its list_elem from the parent list when it
  exits since it already freed.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
